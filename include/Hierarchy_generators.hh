#ifndef HIERARCHY_GENERATORS_HH_INCLUDED
#define HIERARCHY_GENERATORS_HH_INCLUDED

#include "Type_traits.hh"

namespace csr
{
    namespace Private
    {
        // The following type helps to overcome subtle flaw in the original
        // implementation of generate_scatter_hierarchy, revealed when the
        // input type list of generate_scatter_hierarchy contains more than
        // one element of the same type (e.g. typelist<int,int>). In this
        // case generate_scatter_hierarchy would contain multiple bases of
        // the same type and some of them will not be reachable because of
        // lack of uniqueness. For example before the fix the first element of
        // tuple<typelist<int,int> > is not reachable in any way!
        // The technique is to ensure at some point a 2 elems typelist
        // instantiation of generate_scatter_hierarchy is generated by an
        // explicit specialization of the template for
        // Private::scatter_hierarchy_tag. The type is not even constructed.
        template<typename,typename>
        struct scatter_hierarchy_tag;
    }

    template<typename TList,template<typename> class Unit>
    class generate_scatter_hierarchy;

    template<typename T1,typename T2,template<typename> class Unit>
    class generate_scatter_hierarchy<typelist<T1,T2>,Unit>
    :   public generate_scatter_hierarchy
                <
                    Private::scatter_hierarchy_tag<T1,T2>,Unit
                >,
        public generate_scatter_hierarchy<T2,Unit>
    {
    public:
        typedef typelist<T1,T2> type_list;
        // Insure that left_base is unique and therefore reachable
        typedef generate_scatter_hierarchy
                <
                    Private::scatter_hierarchy_tag<T1,T2>,Unit
                > left_base;
        typedef generate_scatter_hierarchy<T2,Unit> right_base;

        template<typename T> struct rebind
        {
            typedef Unit<T> result;
        };
    };

    // Here's the specialization needed to make the base *unique* and therefore
    // resolve possible ambiguity
    template<typename T1,typename T2,template<typename> class Unit>
    class generate_scatter_hierarchy<Private::scatter_hierarchy_tag<T1,T2>,Unit>
    :   public generate_scatter_hierarchy<T1,Unit> {};

    template<typename AtomicType,template<typename> class Unit>
    class generate_scatter_hierarchy
    :   public Unit<AtomicType>
    {
        typedef Unit<AtomicType> left_base;

        template<typename T> struct rebind
        {
            typedef Unit<T> result;
        };
    };

    // This specialization stops recursivity
    template<template<typename> class Unit>
    class generate_scatter_hierarchy<void_t,Unit>
    {
        template<typename T> struct rebind
        {
            typedef Unit<T> result;
        };
    };

    template<typename T> struct tuple_unit
    {
        T value_;
        operator T&() { return value_; }
        operator const T&() const { return value_; }
    };

    template<typename TList>
    struct tuple
    :   public generate_scatter_hierarchy<TList,tuple_unit> {};

    template<typename H,unsigned int N> struct field_helper;

    template<typename H> struct field_helper<H,0>
    {
        typedef typename H::type_list::head                    element_type;
        typedef
            typename H::template rebind<element_type>::result  unit_type;
        typedef tuple_unit<element_type>                        tuple_element;

        enum
        {
            is_tuple = conversion<unit_type,tuple_element>::same_type,
            is_const = type_traits<H>::is_const
        };

        typedef const typename H::left_base                 const_left_base;

        typedef typename select<is_const,const_left_base,
                                typename H::left_base>::result left_base;

        typedef typename select<is_tuple,element_type,
                                unit_type>::result unqualified_result_type;

        typedef typename select<is_const,const unqualified_result_type,
                                unqualified_result_type>::result result_type;

        static result_type& get(H& obj)
        {
            left_base& leftBase = obj;
            return leftBase;
        }
    };

    template<typename H,unsigned int N> struct field_helper
    {
        typedef
            typename type_at<typename H::TList,N>::result    element_type;
        typedef
            typename H::template rebind<element_type>::result   unit_type;
        typedef tuple_unit<element_type>                        tuple_element;
        enum
        {
            is_tuple = conversion<unit_type,tuple_element>::same_type,
            is_const = type_traits<H>::is_const
        };

        typedef const typename H::right_base                const_right_base;

        typedef typename select<is_const,const_right_base,
                                typename H::right_base>::result right_base;

        typedef typename select<is_tuple,element_type,
                                unit_type>::result unqualified_result_type;

        typedef typename select<is_const,const unqualified_result_type,
                                unqualified_result_type>::result result_type;

        static result_type& get(H& obj)
        {
            right_base& rightBase = obj;
            return field_helper<right_base,N - 1>::get(rightBase);
        }
    };

    template<int N,typename H>
    typename field_helper<H,N>::result_type& field(H& obj)
    {
        return field_helper<H,N>::get(obj);
    }

    template<int N,typename H>
    typename field_helper<H,N>::result_type& field(const H& obj)
    {
        return field_helper<H,N>::get(obj);
    }

    template
    <
        typename TList,
        template<typename AtomicType,typename Base> class Unit,
        typename Root = void_t
    >
    struct generate_linear_hierarchy;

    template
    <
        typename T1,
        typename T2,
        template<typename,typename> class Unit,
        typename Root
    >
    struct generate_linear_hierarchy<typelist<T1,T2>,Unit,Root>
    :   public Unit<T1,generate_linear_hierarchy<T2,Unit,Root> > {};

    template
    <
        typename T,
        template<typename,typename> class Unit,
        typename Root
    >
    struct generate_linear_hierarchy<typelist<T,void_t>,Unit,Root>
    :   public Unit<T,Root> {};
}

#endif // HIERARCHY_GENERATORS_HH_INCLUDED
